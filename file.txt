# 2 / для отсутствующих значений подбор буквdf
from itertools import *
def f(x, y, w, z): return ((w <= (not(x))) == (z <= y)) and (y or w)

for a1, a2 in product([0, 1], repeat=2): # отсутствуют 2 значения, a1 и a2
    table = [(1, 1, 1, 0), (0, 0, 1, 1), (0, a1, 0, a2)]
    if len(table) == len(set(table)):
        for p in permutations("xywz"):
            if [f(**dict(zip(p, r))) for r in table] == [0, 1, 1]: # значения функций в таблице
                print(p)



# 8 / если важен порядок
a = {0: "А", 1: "К", 2: "Р", 3: "У"} # алфавитный порядок
k = 0
for i in range(0, len(a)):
    for j in range(0, len(a)):
        for g in range(0, len(a)):
            for m in range(0, len(a)):
                for n in range(0, len(a)):
                    k += 1
                    if i == 3 and j == 1 and g == 0 and m == 2 and n == 0: # слово по буквам из словаря
                        print(k)
# itertools product - любые комбинации из символов с любым количеством повторов
# itertools permutations - комбинации без повторов permutations("печка", r=3) r = длина. каждый символ ровно 1 раз
# product - комбинации, permutations - перестановки
from itertools import *
cnt = 0
sogl = "МРТ"
glas = "ЕО"
for i in product("МЕТРО", repeat=4):
    if (i[0] in sogl) and (i[3] in glas): # начало и окончание на гласные/согласные
        cnt += 1
print(cnt)

from itertools import *
cnt = 0
for i in product("ABCDX", repeat=4):
    if i.count("X") == 1: # кол-во букв
        cnt += 1
print(cnt)




# 14 / универсальные шаблоны
# разные основания. берется меньшее и по нему сокращается алфавит
alph = sorted("qwertyuiopasdfghjklzxcvbnm0987654321")
for x in alph[:13]: # меньшее основание
    for y in alph[:13]: # можно обойтись без него
        f = int(f"4C{x}4", 15) + int(f"{x}62A", 13)
        if f%121 == 0:
            print(x, y, f // 121)

# разные основания и 2 переменные
alph = sorted("qwertyuiopasdfghjklzxcvbnm0987654321")
for x in alph[:9]: # меньшее основание
    for y in alph[:9]:
        f = int(f"88{x}4{y}", 9) + int(f"7{x}44{y}", 11)
        if f%61 == 0:
            print(x, y, f // 61)

# одно основание
alph = sorted("qwertyuiopasdfghjklzxcvbnm0987654321")
for x in alph[:15]: # основание
    f = int(f"123{x}5", 15) + int(f"1{x}233", 15)
    if f % 14 == 0: # кратность что нужно для ответа
        print(x, f//14)

# строчный вариант задания
s = 4**2020 + 2*2017 - 15
a = []
while s > 0:
    a = [s%3] + a # где 3 это система счисления
    s = s//3
print(a.count(1))



# 15 / решения почти на все

# задача на ДЕЛ
def f(x): return (not(x%a == 0)) <= ((x%6 == 0) <= (not(x%4==0))) # формула из условия

for a in range(1, 100000):
    if all(f(x) == 1 for x in range(1, 10000000)):
        print(a)


# задача на поразрядную конъюнкцию
def f(x): return (((x&57>0) or (x&99>0)) <= (x&a>0)) # формула из условия

for a in range(1, 100000):
    if all(f(x) == 1 for x in range(1, 10000000)):
        print(a)


# задача на числа(я не помню название)
# v1
def f(x, y): return (y+3*x < a) or (x>20) or (y>40)  # формула из условия

for a in range(1, 100000): # если в условии: "для любых положительных", то в x, y в for начало с 1
    if all(f(x, y) == 1 for x in range(1, 10000000) for y in range(1, 10000000)):
        print(a)

# v2
def f(x, y): return (2*y+3*x < a) or (x+y > 40)  # формула из условия

for a in range(1, 100000): # если в условии: "для любых неотрицательных", то в x, y в for начало с 0
    if all(f(x, y) == 1 for x in range(0, 10000000) for y in range(0, 10000000)):
        print(a)



# 16 / 2 универсальных
def F(n):
    if n < 3:
        return 2
    if n % 2 == 0 and n > 2:
        return F(n - 2) + F(n - 1) - n
    if n % 2 != 0 and n > 2:
        return F(n - 1) - F(n - 2) + 2 * n
print(F(32))

def F(n):
    if n == 1:
        return 1
    if n == 2:
        return 3
    if n > 2:
        return F(n-1) * F(n - 2) + n-2
print(F(5))



# 23 / универсальный шаблон
# import sys
# sys.setrecursionlimit(99999999)
# или
# from functools import *
# @lru_cache(None)
def f(x, y):  # x - начальное число. y - цель
    if x == y: return 1
    if x > y or x == 14: return 0  # or x== исключаемое число
    if x < y: return f(x + 1, y) + f(x * 2, y) + f(x ** 2, y)
print(f(3, 25))  # если включительно определенный элемент, то f(x,y) * f(x, y) * ...



# 27 / без аномалий
clustersA = [[], []]
clustersB = [[], [], []]
for a in open("27A_18054.txt"):
    x, y = [float(k) for k in a.replace(",", ".").split()]
    if y > 5.5:
        clustersA[0].append([x, y])
    elif x > 3:
        clustersA[1].append([x, y])
for b in open("27B_18054.txt"):
    x, y = [float(k) for k in b.replace(",", ".").split()]
    if x > 3 and y > -1.3:
        clustersB[0].append([x, y])
    elif x < 3 and y > -2.5:
        clustersB[1].append([x, y])
    else:
        clustersB[2].append([x, y])
def dist(a, b):
    x1, y1 = a
    x2, y2 = b
    return max(abs(x2-x1), abs(y2-y1))

def center(cl):
    m = []
    for p in cl:
        sm = sum(dist(p, p1) for p1 in cl)
        m.append([sm, p])
    return min(m)[1]

centerA = [center(cl) for cl in clustersA]
centerB = [center(cl) for cl in clustersB]
pxA = sum(x for x, y in centerA) / 2 * 10000
pyA = sum(y for x, y in centerA) / 2 * 10000
pxB = sum(x for x, y in centerB) / 2 * 10000
pyB = sum(y for x, y in centerB) / 2 * 10000

print(int(pxA), int(pyA))
print(int(pxB), int(pyB))
